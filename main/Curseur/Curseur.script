-- Cursor
go.property("wheelclick", false) -- Wheel pressed ?
go.property("wheelclick_pos", 0) -- pos of the cursor on the screen
go.property("wheelclick_camera_pos", 0) -- 
-- Last time click
go.property("pressed_time", socket.gettime())
go.property("wheel", 0) -- Allow the wheel function to accept inputs.
-- Gui
-- go.property("gui", 0)

function screen_to_world(x, y, z)

	local projection = go.get("/Camera#camera", "projection")
	local view = go.get("/Camera#camera", "view")
	local w, h = window.get_size()
	-- The window.get_size() function will return the scaled window size,
	-- ie taking into account display scaling (Retina screens on macOS for
	-- instance). We need to adjust for display scaling in our calculation.
	w = w / (w / game_ref.screen_X)
	h = h / (h / game_ref.screen_Y)

	-- https://defold.com/manuals/camera/#converting-mouse-to-world-coordinates
	local inv = vmath.inv(projection * view)
	x = (2 * x / w) - 1
	y = (2 * y / h) - 1
	z = (2 * z) - 1
	local x1 = x * inv.m00 + y * inv.m01 + z * inv.m02 + inv.m03
	local y1 = x * inv.m10 + y * inv.m11 + z * inv.m12 + inv.m13
	local z1 = x * inv.m20 + y * inv.m21 + z * inv.m22 + inv.m23
	return x1, y1, z1
end

local function CollisionOrbital(self)
	local max_id = nil
	local max_orbital = nil
	local max_time = -math.huge
	for etoile, data in pairs(collision_global_orbital) do
		if data.time > max_time then
			max_time = data.time
			max_id = etoile
			max_orbital = data.orbital
		end
	end
	if max_id ~= nil then
		reponse = {type = "orbitale", etoile = max_id, orbitale = max_orbital}
		return reponse
	end
end

local function CollisionEtoile(self)
	local max_id = nil
	local max_value = -math.huge
	for id, value in pairs(collision_global_etoile) do
		if value > max_value then
			max_value = value
			max_id = id
		end
	end
	if max_id ~= nil then
		reponse = {type = "etoile", etoile = max_id}
		return reponse
	end
end

local function CollisionGui(self)
	local max_id = nil
	local max_niveau = -math.huge
	for id, data in pairs(self.gui) do
		if data.niveau > max_niveau and data.entree then
			max_niveau = data.niveau
			max_id = id
		end
	end
	if max_id ~= nil then
		reponse = {type = "gui", id = max_id}
		return reponse
	end
end

local function Wheel_Zoom(sens, self)
	self.wheel = 0
end

local function Wheel_Zoom_Elements(tint1, self)

	
	for i = 1,galaxie["Nombre_Etoiles"] do 
		local tmp_Etoile = galaxie.etoiles.id[i]["/StarSystem"]
		local tmp_Etoile_Label = galaxie.etoiles.id[i]["/StarSystemLabel"]
		local lointaine = msg.url(nil, tmp_Etoile, "Etoile")
		local proche = msg.url(nil, tmp_Etoile, "Etoile_proche")
		-- local label = msg.url(nil, tmp_Etoile_Label, "label")
		if tint1 < 2 then
			sprite.set_constant(proche, "tint", vmath.vector4(1, 1, 1, tint1))
		end

		--	go.set(tmp_Etoile, "scale.y", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		--	go.set(tmp_Etoile, "scale.x", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))		

		go.set("/Curseur#sprite", "scale.x", 1*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set("/Curseur#sprite", "scale.y", 1*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

		go.set(lointaine, "scale.y", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set(lointaine, "scale.x", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

		go.set(proche, "scale.y", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set(proche, "scale.x", 1.5*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

		go.set(tmp_Etoile_Label, "position.y", -32*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set(tmp_Etoile_Label, "scale.y", 2*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set(tmp_Etoile_Label, "scale.x", 2*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

		
		-- set sphere shape data
		--local sphere_data = {
		--	type = physics.SHAPE_TYPE_SPHERE,
		--	diameter = 10,
		--}
		-- physics.set_shape("#collisionobject", "my_sphere_shape", sphere_data)

		
		-- Show / Hide stars label
		if game_ref.zoom.state == game_ref.zoom.show_label+1 then
			msg.post(tmp_Etoile_Label, "enable")
		elseif game_ref.zoom.state == game_ref.zoom.show_label then
			msg.post(tmp_Etoile_Label, "disable")
		end		

		-- Star System screen - general box
		--if self.gui["Screen_Star"]["etat"] then
			go.set("/Screen_Star/Screen_Star#Fond_pixel", "scale.y", 1080*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
			go.set("/Screen_Star/Screen_Star#Fond_pixel", "scale.x", 320*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
			-- Star System screen - collision box
			local coll_shape = {}
			coll_shape.type = physics.SHAPE_TYPE_BOX
			coll_shape.dimensions = vmath.vector3(320*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)), 1080*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)), 0)
			physics.set_shape("/Screen_Star/Screen_Star#collisionobject", "Collision", coll_shape)
		--end
	end
end


function init(self)

	-- State of the different GUI elements (enabled true, disabled false)
	self.gui = {}
	self.gui["Screen_Star"] = {niveau = 1, url = msg.url("/Screen_Star/Screen_Star"), etat = false, entree = false}


	msg.post(".", "acquire_input_focus")

end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)

	
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)

	if message_id == hash("GUI_entree") then
		if message.gui == "Screen_Star" then
			if message.entree then
				self.gui["Screen_Star"]["entree"] = 1
				print("entrée")
			else
				self.gui["Screen_Star"]["entree"] = false
				print("sortie")
			end
		end
	end

end

function on_input(self, action_id, action)
	local position = go.get_position()
	
	local position_camera = go.get_position("/Camera#camera")

	local reponse = nil
	
	if action.x and action.y then
		local action_x, action_y = screen_to_world(action.x, action.y, 9)
		local a = vmath.vector3(action_x, action_y, 1)
		go.set_position(a, ".")	
	end
	
	if action_id == hash("Touch") and action.pressed then

		-- Does the cursor click on a object on the map ?)
		local attempts = {CollisionGui, CollisionOrbital, CollisionEtoile}
		local value = nil
		for _, attempt in ipairs(attempts) do
			value = attempt(self)
			if value ~= nil then
				break
			end
		end
		-- self.gui["Screen_Star"]["entree"] == false
		if value ~= nil then
			-- pprint("click en dehors GUI :" .. tostring(self.gui["Screen_Star"]["entree"]))
			
			if value.type == "gui" then
				print ("Click sur un élément GUI")
			elseif value.type == "orbitale" then
				self.gui["Screen_Star"]["etat"] = true 
				msg.post(self.gui["Screen_Star"]["url"], "enable")
				msg.post(self.gui["Screen_Star"]["url"], "click", {orbital = value.orbitale, etoile = value.etoile})
			elseif  value.type == "etoile" then
				self.gui["Screen_Star"]["etat"] = true
				msg.post(self.gui["Screen_Star"]["url"], "enable")
				msg.post(self.gui["Screen_Star"]["url"], "click", {orbital = false, etoile = value.etoile})
			end
		else
			self.gui["Screen_Star"]["etat"] = false
			msg.post(self.gui["Screen_Star"]["url"], "disable")
			print("Deep space, home of unspeakable horrors from forgotten time...")
		end

		-- self.gui_etat["Screen_Star"] = {url = msg.url("/Screen_Star/Screen_Star"), etat = false}
		
	end

	if action.released then
		self.wheelclick = false
	elseif (action.pressed  and (action_id == hash("wheelclick"))) then
		self.wheelclick = true
		self.wheelclick_pos = vmath.vector3(action.x, action.y, 10)
		self.wheelclick_camera_pos = position_camera
	end
	
	if self.wheelclick == true then
		-- moving camera with the mouse
		local pos = self.wheelclick_camera_pos + (self.wheelclick_pos - vmath.vector3(action.x, action.y, 0)) *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state))
		if pos.x < 1 then
			pos.x = 1
		end
		if pos.y < 1 then
			pos.y = 0
		end
		if pos.x > galaxie.Taille.Map_X then
			pos.x = galaxie.Taille.Map_X
		end
		if pos.y > galaxie.Taille.Map_Y then
			pos.y = galaxie.Taille.Map_Y
		end
		-- go.set_position(pos)			
		go.set_position(pos,"/Camera#camera")
	elseif action_id == hash("Up") and (position_camera.y < galaxie.Taille.Map_Y)  then
		position.y = position.y + (5 *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		position_camera.y = position_camera.y + (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set_position(position)
		go.set_position(position_camera,"/Camera#camera")
	elseif action_id == hash("Down") and (position_camera.y > 0) then
		position.y = position.y - (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		position_camera.y = position_camera.y - (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set_position(position)
		go.set_position(position_camera,"/Camera#camera")
	elseif action_id == hash("Left") and (position_camera.x > 0) then
		position.x = position.x - (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		position_camera.x = position_camera.x - (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set_position(position)
		go.set_position(position_camera,"/Camera#camera")
	elseif action_id == hash("Right") and (position_camera.x < galaxie.Taille.Map_X) then
		position.x = position.x + (5 *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		position_camera.x = position_camera.x + (5  *(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
		go.set_position(position)
		go.set_position(position_camera,"/Camera#camera")

		-- zooming
	elseif action_id == hash("wheelup") and self.wheel < 1 and game_ref.zoom.max > game_ref.zoom.state  then
		self.wheel = 1
		Wheel_Zoom(1, self)
		game_ref.zoom.state = game_ref.zoom.state + 1
		go.set("/Camera#camera", "orthographic_zoom", 1*(math.pow(game_ref.zoom.gap, game_ref.zoom.state)))
		if game_ref.zoom.state == game_ref.zoom.proche+1 then
			Wheel_Zoom_Elements(1, self)
		else
			Wheel_Zoom_Elements(2, self)
		end
	elseif action_id == hash("wheeldown") and self.wheel < 1 and game_ref.zoom.min < game_ref.zoom.state  then
		self.wheel = 1
		Wheel_Zoom(2, self)
		game_ref.zoom.state = game_ref.zoom.state - 1
		go.set("/Camera#camera", "orthographic_zoom", 1*(math.pow(game_ref.zoom.gap, game_ref.zoom.state)))
		if game_ref.zoom.state == game_ref.zoom.proche then
			Wheel_Zoom_Elements(0, self)
		else
			Wheel_Zoom_Elements(2, self)
		end
	end
	
end
