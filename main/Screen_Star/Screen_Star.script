function init(self)
	msg.post(".", "disable")
	
	-- Adapt the pixel image of background
	go.set("#Fond_pixel", "scale.y", 1080*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
	go.set("#Fond_pixel", "scale.x",  320*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

	-- Adapt the Collision shape size

	self.collision_url = msg.url("#collisionobject")
	local coll_shape = {}
	coll_shape.type = physics.SHAPE_TYPE_BOX
	coll_shape.dimensions = vmath.vector3(320*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)), 1080*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)), 0)
	physics.set_shape("#collisionobject", "Collision", coll_shape)
	
	
	local world_x, world_y  = screen_to_world(160, game_ref.screen_Y/2,1)
	go.set_position(vmath.vector3(world_x, world_y, 4), ".")


--	local box = physics.get_shape("#collisionobject", "my_box")
--	box.dimensions = vmath.vector3(320*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)),1080*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)),15)
--	physics.set_shape("#collisionobject", "my_box", box)
--
--	-- Label : Star name
--
--	go.set("Label_Star_Name", "scale.x", 1*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
--	go.set("Label_Star_Name", "scale.y", 1*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))
--	go.set("Label_Star_Name", "position.y", 500*(math.pow(game_ref.zoom.gap, -game_ref.zoom.state)))

	
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	local world_x, world_y  = screen_to_world(160, game_ref.screen_Y/2,1)
	go.set_position(vmath.vector3(world_x, world_y, 4), ".")
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("click") then
		if message.orbital then
			pprint("Orbital : I'm clicked ! " .. message.orbital .. " -- " .. galaxie.etoiles.nom[message.etoile])
		elseif message.etoile then
			pprint("Star : I'm clicked ! ".. galaxie.etoiles.nom[message.etoile])
		else
			pprint("Screen_Star : What has been clicked ? -- line 61")
			pprint(message)
		end
	elseif message_id == hash("trigger_response") then
		-- If cursor enter the local Collision box
		if message.enter then
			-- take action for entry
			msg.post("/Curseur", "GUI_entree", {gui = "Screen_Star", entree = true})
		elseif message.enter == false then
			-- take action for exit
			msg.post("/Curseur", "GUI_entree", {gui = "Screen_Star", entree = false})
		end	
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
